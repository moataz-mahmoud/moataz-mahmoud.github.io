I"Ø“<h2 id="motivation">Motivation</h2>

<p>Ten years ago, websites tended to offer a very specific series for the users. But day by day, this idea got demolished and huge corporates tended to put as many features as possible in a single website. For example, previously you were visiting Facebook only to share your updates for your friends and connections. Currently, you can visit Facebook and go live, selling some of your stuff, shopping online, attend watch parties, get a list of events in a specific location, attended online courses, and so many more. The same idea for many of big companies such as Amazon, Booking, and uber. Even for those applications which are specifically produces one service, there is a much huge details and complementaries about this service are offered now compared to many years ago. Google maps is a good example here.</p>

<p>The more websites get more complex, the more release process turns into headache. Until some stages, where the release may turn literally into a nightmare. And one steps into the road to get rid of that nightmare is to use test automation. In the normal process of release, you are interested in two testing processes. The first one is testing the release tasks and all the areas of the software which may be affected with those tasks. And other one is testing the whole software to make sure that the new features didn‚Äôt harm the software in any of its parts deliberately or not. We call this type of testing <strong>regression testing</strong>. Testing the release task could be done manually easily (when it‚Äôs preferred to be done automotive), but the regression testing is not efficient to be done manually. Most of time, your system has many thousands of test cases. Running all of them manually every release consumes too much time. Also, if you had the time, the eyes of the testing team get used to the function of the system. So, they assume that all the parts of the system that were working well in the previous releases will work normally here. Especially those features which we didn‚Äôt edit them. But the actual result may differ.</p>

<blockquote>
  <p>As conclusion, we need to develop automation test plan for the regression testing automating all the test cases which we need to run every release.</p>
</blockquote>

<h2 id="whats-end-to-end-testing">What‚Äôs end-to-end testing</h2>

<p>When we are talking about web-based automation testing. There are many stages you as a software tester should implement automation testing. The first stage and the straightest forward is to try to simulate every simple action that your website user can do from the browser. This type of testing is called <strong>end-to-end testing</strong> or simply e2e.  The second stage is the API testing level. At this stage you simply write automation scripts to test the expected response of every end point in your system. At another stage you do the integration testing. At the complex systems, the developers implement unit tests to test every component isolated to the system (in all the systems actually they should not only the complex ones). So, the development team sends you a collection of components everyone is confirmed that it‚Äôs working as expected on its own. And you as a tester should develop scripts to make sure that those components will be coherent when they are talking to each other. This series will focus only on the first stage which is e2e. Maybe we cover the other stages later.</p>

<h2 id="end-to-end-testing-workflow">End-to-end testing workflow</h2>

<p>When we are building test scripts, there are three main layers in the architecture.<br />
Here is a picture which shows the 3 main component of a testing framework</p>
<p align="center"> <img src="/assets/images/e2e-workflow.jpg" /> </p>
<ol>
  <li><strong>Real Browser:</strong> You must have at least one of the browsers installed on the machine to be able to create and run the tests. It‚Äôs recommended to install all the browsers that your clients will use.</li>
  <li><strong>Selenium WebDriver:</strong> For every real browser, there is a Selenium driver. For example, if you want to run your tests against Google Chrome, you need to install Selenium‚Äôs Chrome WebDriver. And so on ‚Ä¶</li>
  <li><strong>Testing Bindings:</strong> Here is where our comparison fits in. Whatever we will use Selenium Java or any of the JavaScript libraries, you MUST have the above two layers. Then, you need to use one of the automation tools. Either to use one of the Selenium‚Äôs extensions. And in this area, Java is the most powerful option (to be discussed in detail below). The other option you can use one of the JavaScript libraries that can do the job for you. There are many options here too. You can use Protractor, TestCafe, or Cypress.</li>
</ol>

<h2 id="why-to-use-protractor">Why to use Protractor</h2>

<p>It‚Äôs no secret to anyone that Selenium is the most popular tool to be used in e2e automation. There are two main reasons behind that popularity. First, it was the first major stable tool appeared. So, the testers started using it heavily before the other frameworks come to the arena. And step by step it becomes harder and harder to replace the old code written in Selenium by any other new framework. The other reason that it supports many programming languages. And mostly, the testers aren‚Äôt the best programmers in the field. So, as a tester, you may have a hands-on experience only coding in one or two programming language. So, it‚Äôs easier and more practical for you to start using a tool with whatever the programming language you know that learning a completely new programming language to start automating in another framework. But let‚Äôs talk more practically, is Selenium really the best option? For me, at least, nope! Protractor is better for me and more practical. And here are some reasons why Protractor is my favorite pick:</p>

<ul>
  <li><strong>Protractor works perfectly for both angular and non angular apps:</strong> Protractor was built basically to test angular pages. But it‚Äôs no longer than a few months until they make it supports non-angular pages with only a small flag added to the config file. In case of Selenium, it was built for testing the non-angular pages, but when it comes to angular ones, it suffers. Selenium will work in Angularjs , but it will get synchronization issues. Selenium WebDriver code is not friendly for Behavior Driven Development such as jasmine and mocha. Angularjs needs to identify the elements which are not recognized by Selenium for ex: ng-model, css, ‚Ä¶ etc. But in Selenium Webdriver this can be achieved only via the required identifiers or unique class to access the elements. It takes more effort and time, when does the same in Selenium. Someone may say that Protractor uses Selenium webdriver and it uses the Selenium js driver with its own wrapper to support angular context helper methods, but why we need to prefer use of Protractor than Selenium for testing Angular and Angularjs applications? Well, it‚Äôs true that Protractor uses Selenium js driver with its own wrapper, but Protractor provides some new locating strategies which are very helpful to automate the Angular applications. For example, Protractor provides you with waitForAngular, By.binding, By.repeater, By.testarea, By.model, ‚Ä¶ etc. Sometimes it is difficult to capture the web elements in AngularJS applications using JUnit or Selenium Webdriver. Protractor supports Angular-specific locator strategies, which allows you to test Angular-specific elements without any setup effort on your part. Also, Protractor has the addLocator function to help you add your own locators. So that, for a fictional example, you can get elements by their handlebar‚Äôs properties.</li>
  <li><strong>Protractor is much easier to develop:</strong> To discover how easier Protractor development compared to Selenium (regardless your knowledge in JavaScript), go ahead and spot the differences between this example written once in Protractor and another with Selenium.</li>
</ul>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Google Search</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should work</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">browser</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://www.google.com</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">element</span><span class="p">(</span><span class="nx">by</span><span class="p">.</span><span class="nx">name</span><span class="p">(</span><span class="dl">'</span><span class="s1">q</span><span class="dl">'</span><span class="p">)).</span><span class="nx">sendKeys</span><span class="p">(</span><span class="dl">'</span><span class="s1">webdriver</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">element</span><span class="p">(</span><span class="nx">by</span><span class="p">.</span><span class="nx">name</span><span class="p">(</span><span class="dl">'</span><span class="s1">btnG</span><span class="dl">'</span><span class="p">)).</span><span class="nx">click</span><span class="p">();</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">browser</span><span class="p">.</span><span class="nx">getTitle</span><span class="p">()).</span><span class="nx">toEqual</span><span class="p">(</span><span class="dl">'</span><span class="s1">webdriver - Google Search</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">assert</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">assert</span><span class="dl">'</span><span class="p">),</span>
    <span class="nx">test</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">selenium-webdriver/testing</span><span class="dl">'</span><span class="p">),</span>
    <span class="nx">webdriver</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">selenium-webdriver</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">test</span><span class="p">.</span><span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">Google Search</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">test</span><span class="p">.</span><span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">should work</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">driver</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">webdriver</span><span class="p">.</span><span class="nx">Builder</span><span class="p">().</span>
            <span class="nx">withCapabilities</span><span class="p">(</span><span class="nx">webdriver</span><span class="p">.</span><span class="nx">Capabilities</span><span class="p">.</span><span class="nx">chrome</span><span class="p">()).</span>
            <span class="nx">build</span><span class="p">();</span>

        <span class="nx">driver</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://www.google.com</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">driver</span><span class="p">.</span><span class="nx">findElement</span><span class="p">(</span><span class="nx">webdriver</span><span class="p">.</span><span class="nx">By</span><span class="p">.</span><span class="nx">name</span><span class="p">(</span><span class="dl">'</span><span class="s1">q</span><span class="dl">'</span><span class="p">)).</span><span class="nx">sendKeys</span><span class="p">(</span><span class="dl">'</span><span class="s1">webdriver</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">driver</span><span class="p">.</span><span class="nx">findElement</span><span class="p">(</span><span class="nx">webdriver</span><span class="p">.</span><span class="nx">By</span><span class="p">.</span><span class="nx">name</span><span class="p">(</span><span class="dl">'</span><span class="s1">btnG</span><span class="dl">'</span><span class="p">)).</span><span class="nx">click</span><span class="p">();</span>
        <span class="nx">driver</span><span class="p">.</span><span class="nx">getTitle</span><span class="p">().</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">title</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">title</span><span class="p">,</span> <span class="dl">'</span><span class="s1">webdriver - Google Search</span><span class="dl">'</span><span class="p">);</span>
        <span class="p">});</span>

        <span class="nx">driver</span><span class="p">.</span><span class="nx">quit</span><span class="p">();</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre></div></div>

<p>You can see the huge difference between the ease of development and the readibility as a result. No need to point to which is the Protractor snippet and which is the Selenium. The first one is the Protractor of course.</p>

<ul>
  <li><strong>You don‚Äôt need to add waits or sleeps to your test:</strong> Protractor can communicate with your AngularJS app automatically and execute the next step in your test the moment the webpage finishes pending tasks, so you don‚Äôt have to worry about waiting for your test and webpage to sync.</li>
  <li><strong>Protractor is written in JavaScript which is dynamically typed:</strong> There are too many advantages of using dynamically typed languages in test automation, but the main power is that there is no compile time. In a static typing language, every time you change a single command in your code you need to build it again. But in the dynamically typed languages, there is no more such a burden. Every time you change your code and run, the interpreter won‚Äôt generate a byte code from scratch, it will just start running your code line by line with no need to take the overhead of compilation time. You can get more details about this from <a href="https://tratt.net/laurie/research/pubs/papers/tratt__compile-time_meta-programming_in_a_dynamically_typed_oo_language.pdf">this magnificent paper</a>. What‚Äôs really impressing when using Protractor, that you have the option to use JavaScript directly which is a dynamically typed language or start writing in TypeScript which is a statically typed one. So, you have the luxury of selecting the more suitable option for your project.</li>
  <li><strong>Protracor is much faster than Selenium:</strong> Do you remember the previous example which is written above once in Protractor and another in Selenium? When I tried to run it, it took 11 seconds in case of Protractor compared to 20 seconds for Selenium. Actually, whatever the test that you are running, if you tried to write in once in Protractor and another in Selenium, you will find that most of the cases there is a huge difference in the running tim between Protractor and Selenium.</li>
  <li><strong>Using Jasmine:</strong> Protractor uses Jasmine, the framework you use to write AngularJS unit tests. And Javascript, the same language you use to write AngularJS apps.</li>
  <li><strong>It is easy to set up page objects:</strong> Protractor does not perform WebDriver commands till an action is needed, i.e., set up page objects so that tests can operate page elements without moving the HTML.</li>
</ul>

<h2 id="getting-things-ready">Getting things ready</h2>

<p>In order to write protractor tests the only mandatory prerequisite is getting protractor installed. And to get protractor install all what you need is node installed on your machine. But there are many other components that can ease the process of development. So, first of all let‚Äôs get node and protractor installed and then install the other preferences.
The first thing to install is node.js. And you can find a full guide to install it on whatever platform through <a href="https://nodejs.org/en/download/package-manager/">this tutorial</a>.
To make sure that node is installed on your version, just open your terminal and type <code class="highlighter-rouge">npm --version</code>.
The next step is to install Protractor. And it can be simply done from the terminal by the following command:</p>

<p><code class="highlighter-rouge">npm install -g protractor</code></p>

<p>This will install two command line tools, protractor and webdriver-manager. Try running <code class="highlighter-rouge">protractor --version</code> to make sure it‚Äôs working. The webdriver-manager is a helper tool to easily get an instance of a Selenium Server running. At the very early beginning, you should be able to use it to download the necessary binaries with <code class="highlighter-rouge">webdriver-manager update</code></p>

<p>The next tool to be installed is VSCode. It‚Äôs not mandatory to use VSCode. You can use whatever text editor you like, when of cource VSCode is one of the best and richest with its huge set of plugins and extensions. We will work through this tutorial on VSCode, but it will be highly similar to the other text editors. Its installation process is straight forward. All you need is just download the suitable version according to your operating system from <a href="https://code.visualstudio.com/download">here</a> and then install it as you do for any software tool on your machine.</p>

<p>Now we will work step by step on how to create a new test project and configure it to be able to use TypeScript to write your first Protractor test.</p>

<p>The first step will be to create a folder for your test project. Then open this folder using VSCode, and click <code class="highlighter-rouge">ctrl + ~</code> to open the terminal. Again type <code class="highlighter-rouge">npm -v</code> to make sure that your project can see the globally installed version of node. Now type <code class="highlighter-rouge">npm init</code>. This command is to initialize the project for you. And after this command runs successfully, you can find that there is a package.json file got created for you. By default the content of this file should be something like that:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"test"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1.0.0"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"main"</span><span class="p">:</span><span class="w"> </span><span class="s2">"index.js"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"echo </span><span class="se">\"</span><span class="s2">Error: no test specified</span><span class="se">\"</span><span class="s2"> &amp;&amp; exit 1"</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"author"</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="p">,</span><span class="w">
  </span><span class="nl">"license"</span><span class="p">:</span><span class="w"> </span><span class="s2">"ISC"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>We will add our dependencies in the bottom of this file, after the last line <code class="highlighter-rouge">"licencse": "ISC"</code> add the next code segment.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">  </span><span class="nl">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"@types/jasmine"</span><span class="p">:</span><span class="w"> </span><span class="s2">"~3.5.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"@types/node"</span><span class="p">:</span><span class="w"> </span><span class="s2">"~12.12.21"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"protractor"</span><span class="p">:</span><span class="w"> </span><span class="s2">"~5.4.2"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"jasmine"</span><span class="p">:</span><span class="w"> </span><span class="s2">"~3.5.0"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"typescript"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^3.6.2"</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>In the dependencies section we are defining three main frameworks. The first is <strong>Protractor</strong>, which is the framework we will use to write the e2e tests. The second is Jasmine. <strong>Jasmine</strong> is a behavior-driven development framework for testing JavaScript code. It does not depend on any other JavaScript frameworks. It does not require a DOM. And it has a clean, obvious syntax so that you can easily write tests. And finally <strong>TypeScript</strong>. TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. It supports any browser, any host, any OS, and it‚Äôs open source as well. TypeScript compiles to clean, simple JavaScript code which runs on any browser, in Node.js, or in any JavaScript engine that supports ECMAScript 3 (or newer). TypeScript offers support for the latest and evolving JavaScript features, including those from ECMAScript 2015 and future proposals, like async functions and decorators, to help build robust components.</p>
<blockquote>
  <p>There are two <strong>BIG</strong> advantages to use TypeScript instead of plain JavaScript. The first is intelliSense. IntelliSense is a code-completion aid that includes a number of features: List Members, Parameter Info, Quick Info, and Complete Word. These features help you to learn more about the code you‚Äôre using, keep track of the parameters you‚Äôre typing, and add calls to properties and methods with only a few keystrokes.</p>
</blockquote>

<blockquote>
  <p>And the second main advantage is that TypeScript supports OOP originally. But you may ask why it‚Äôs that important to use OOP in an e2e test framework? Well, this point will be discussed in the last section when it comes to discussing the (POM) Page Object Models section.</p>
</blockquote>

<p>After adding your dependencies to the package.json file, you now need to install them. And to do that all what you need is just going to the terminal and type <code class="highlighter-rouge">npm install</code>. This command will install all the dependencies that are included in the package.json file and it‚Äôs not installed before. So in case that there is a tool installed before -as for protractor in our case- the npm will review the version and set the current project to the mentioned version in the package.json file.</p>

<p>In addition to add the dependencies, we need also to edit the <code class="highlighter-rouge">scripts</code> section. This section shows what are the scripts to be run when this project is run. Edit the scripts file to something like that:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"tsc"</span><span class="p">:</span><span class="w"> </span><span class="s2">"tsc"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"pretest"</span><span class="p">:</span><span class="w"> </span><span class="s2">"npm run tsc"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"test"</span><span class="p">:</span><span class="w"> </span><span class="s2">"protractor convertedjs/specs/landing-page/config.js"</span><span class="w">
  </span><span class="p">}</span><span class="err">,</span><span class="w">
</span></code></pre></div></div>

<p>The first script is the transpiler and will be discussed in detail in a few lines. The second script contains a script which will be run before the third one. So, if the third script is tagged as ‚Äútest‚Äù the second one has to be ‚Äúpretest‚Äù. And in this example, that command runs the transpiler. Will discuss the whole story of the transpiler very soon. The last script is the name of your test and it will be a shorthand to the traditional way to run a protractor test. To run a protractor test you need to type <code class="highlighter-rouge">protractor config.js</code> where config.js is the configuration file of your tests (will be discussed in the next section). But just to abbreviate it every time in the running, we map <code class="highlighter-rouge">protractor path/to/configuration/file</code> to a placeholder which is simply ‚Äútest‚Äù. You can use any placeholder according to the feature that you are testing. For example, it may be ‚Äúlogin‚Äù for login test script, ‚Äúdashboard‚Äù for dashboard test script and so on. We will take a look a little bit later about running the project, don‚Äôt worry! Just edit the scripts section and jump to the next part.</p>

<p>You can see that once you run <code class="highlighter-rouge">npm install</code> for the first time, npm creates a <code class="highlighter-rouge">node_modules</code> folder to save all the installed dependencies in it. So, if you open that node_modules folder, you will find too many subfolders including the dependencies you have installed. Now, in node_modules &gt; typescript &gt; bin folder, you will find a tsc file. This file is called the <strong>transpiler</strong>. The function of that transpiler is simple. It just converts the written TypeScript into JavaScript. As you may know, TypeSctipt can‚Äôt be run directly to a machine. It needs an intermediate layer to transfer it to JavaScript and then run the JavaScript. But wait a minute! Why to write in TypeScript when it will be converted to JavaScript at the end? Why not to use JavaScript directly? The reason is developing in TypeScript is more features rich. As we mentioned before, it supports intellisence and has OOP by its nature. So, you will get the advantage of those features and write from your end in TypeScript. And don‚Äôt bother with the running process. All what you need is just call the transpiler and it will translate the written TypeScript to JavaScript and run it. Also, after we will try this feature, we will find that the generated JavaScript is much more readable for the machine more than any JavaScript that any human being can develop. Yes, it‚Äôs less human-readably, but it doesn‚Äôt matter. You won‚Äôt need to read the converted JavaScript. All your focus will be on TypeScript.</p>

<p>I understand that at the first glance it may be a little bit confusing. But believe me, you will feel how easy it is once you start use it. So don‚Äôt hurry <em>;)</em></p>

<p>Now we need to configure this project‚Äôs transpiler. And to do so we need to use <code class="highlighter-rouge">--init</code> option to generate the transpiler‚Äôs configuration file. So type <code class="highlighter-rouge">node_modules/typescript/bin/tsc --init</code> and a tsconfig.json file will be generated. Open this file, and after neglecting all the commented commands, it looks like:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"compilerOptions"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
   </span><span class="nl">"target"</span><span class="p">:</span><span class="w"> </span><span class="s2">"es5"</span><span class="p">,</span><span class="w">                          </span><span class="err">/*</span><span class="w"> </span><span class="err">Specify</span><span class="w"> </span><span class="err">ECMAScript</span><span class="w"> </span><span class="err">target</span><span class="w"> </span><span class="err">version:</span><span class="w"> </span><span class="err">'ES</span><span class="mi">3</span><span class="err">'</span><span class="w"> </span><span class="err">(default)</span><span class="p">,</span><span class="w"> </span><span class="err">'ES</span><span class="mi">5</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'ES</span><span class="mi">2015</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'ES</span><span class="mi">2016</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'ES</span><span class="mi">2017</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'ES</span><span class="mi">2018</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">'ES</span><span class="mi">2019</span><span class="err">'</span><span class="w"> </span><span class="err">or</span><span class="w"> </span><span class="err">'ESNEXT'.</span><span class="w"> </span><span class="err">*/</span><span class="w">
    </span><span class="nl">"module"</span><span class="p">:</span><span class="w"> </span><span class="s2">"commonjs"</span><span class="p">,</span><span class="w">                     </span><span class="err">/*</span><span class="w"> </span><span class="err">Specify</span><span class="w"> </span><span class="err">module</span><span class="w"> </span><span class="err">code</span><span class="w"> </span><span class="err">generation:</span><span class="w"> </span><span class="err">'none'</span><span class="p">,</span><span class="w"> </span><span class="err">'commonjs'</span><span class="p">,</span><span class="w"> </span><span class="err">'amd'</span><span class="p">,</span><span class="w"> </span><span class="err">'system'</span><span class="p">,</span><span class="w"> </span><span class="err">'umd'</span><span class="p">,</span><span class="w"> </span><span class="err">'es</span><span class="mi">2015</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">or</span><span class="w"> </span><span class="err">'ESNext'.</span><span class="w"> </span><span class="err">*/</span><span class="w">
    </span><span class="nl">"strict"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">                           </span><span class="err">/*</span><span class="w"> </span><span class="err">Enable</span><span class="w"> </span><span class="err">all</span><span class="w"> </span><span class="err">strict</span><span class="w"> </span><span class="err">type-checking</span><span class="w"> </span><span class="err">options.</span><span class="w"> </span><span class="err">*/</span><span class="w">
    </span><span class="nl">"esModuleInterop"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">                  </span><span class="err">/*</span><span class="w"> </span><span class="err">Enables</span><span class="w"> </span><span class="err">emit</span><span class="w"> </span><span class="err">interoperability</span><span class="w"> </span><span class="err">between</span><span class="w"> </span><span class="err">CommonJS</span><span class="w"> </span><span class="err">and</span><span class="w"> </span><span class="err">ES</span><span class="w"> </span><span class="err">Modules</span><span class="w"> </span><span class="err">via</span><span class="w"> </span><span class="err">creation</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">namespace</span><span class="w"> </span><span class="err">objects</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">all</span><span class="w"> </span><span class="err">imports.</span><span class="w"> </span><span class="err">Implies</span><span class="w"> </span><span class="err">'allowSyntheticDefaultImports'.</span><span class="w"> </span><span class="err">*/</span><span class="w">
    </span><span class="nl">"forceConsistentCasingInFileNames"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w">  </span><span class="err">/*</span><span class="w"> </span><span class="err">Disallow</span><span class="w"> </span><span class="err">inconsistently-cased</span><span class="w"> </span><span class="err">references</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">same</span><span class="w"> </span><span class="err">file.</span><span class="w"> </span><span class="err">*/</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>No need to go into the details of those options. They are just auto-generated configurations auto generated for getting the transpiler works properly. All the needed here is to add the two following configurations to the end of the CompilerOptions list.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">    </span><span class="nl">"outDir"</span><span class="p">:</span><span class="w"> </span><span class="s2">"convertedjs"</span><span class="err">,</span><span class="w">
    </span><span class="nl">"types"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"jasmine"</span><span class="p">,</span><span class="w"> </span><span class="s2">"node"</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>The first configuration is telling the transpiler where to store the generated converted JavaScript. In this case, it will generate a folder in the main directory of the application with name ‚ÄúoutDir‚Äù. This folder will be created for the first time to run the transpiler. And every further time it will run, will generate a new ‚Äòconvertedjs‚Äô directory replacing the old one. And the next configuration is just telling the transpiler to rely on node and jasmine in the transpiling process.</p>

<p>If we run the transpiler in this way, all the code written in TypeScript in our project will be converted to JavaScript. But we don‚Äôt need the node_modules to be converted. So we will add the last configuration to the end of the config file and outside the CompilerOptions list. This last configuration will be <code class="highlighter-rouge">"execlude": ["node_modules"]</code>.</p>

<h2 id="writing-your-first-test">Writing your first test</h2>

<p>After a pretty long journey of configuring the project, finally here we are to start writing a sample test :D. This part of the turorial just implements a very simple test case. And in the next parts of the tutorial, more advanced test cases will be implemented.</p>

<p>The simple test case will be just opening the website that you are currently reading this article on, and expect that the main title of it is <strong>Moataz Mahmoud</strong>. To do that, we will create two directories in the main project directory. One with name ‚ÄúPOMs‚Äù -stands for Page Object Models-. And the other one is ‚Äúspecs‚Äù. The first folder will contain all the page objects in the test project. And the second folder will contain all the test cases in the project with their configuration. Let‚Äôs talk about every one in detail. In other words, as e2e is all about implementing all the user scenarios, all the script will do is locating elements and interacting with them. The process of locating the elements will be included in the POMs. And the process of building a method for every possible element interaction will be also created in the POMs but be used in the specs.</p>

<h3 id="page-object-models">Page Object Models</h3>

<p>The idea of POMs is considered as a best practice in the software development world. The idea simply is isolating the web elements the script will locate and the methods that will be interacting with them from the rest of the application. And encapsulate them in The main reason behind that is not to get the chance to any script to get the chance to any component of the code to change the item locators. <strong>You can say that the locators are the most valuable and sensitive values in the e2e process as whole. So we are protecting them</strong>. So build a private variable for each web element, and create as much public accessors as needed to deal with that web element. So if there is a button, obviously you will need to click on it. So create a private variable to locate that button, and a public method to click on it.</p>

<p>In our case, we need to locate only one element in one page. We need to locate the element which contains the title in the landing page. So in the POMs directory, create the LandingPage.ts class. And then add one element to it called websiteTitle for example. So the LandingPage.ts file will be something like:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span>  <span class="p">{</span> <span class="nx">element</span><span class="p">,</span> <span class="nx">by</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">protractor</span><span class="dl">'</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">LandingPage</span> <span class="p">{</span>
    <span class="kr">private</span> <span class="nx">websiteTitle</span> <span class="o">=</span> <span class="nx">element</span><span class="p">(</span><span class="nx">by</span><span class="p">.</span><span class="nx">css</span><span class="p">(</span><span class="dl">'</span><span class="s1">.site-title</span><span class="dl">'</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Regarding to the first line, it‚Äôs to import element and by objects from the protractor module. When we are using VSCode and TypeScript, so we can use the auto-complete and auto-import features. All what you need to auto-import any library from any defined module in the node_modules is to type its name and click ctrl + space which is the default auto-complete shortcut in VSCode and automatically it will be imported for you. Do that with both element and by keywords, and the first line will be auto-generated. Don‚Äôt panic with the selection method and what that element and by keywords work. It‚Äôs the topic of the next post.</p>

<p>Now the need to creat a method to deal with that element. Again we don‚Äôt need to let any other component from outside the landing page to be able to change the contents of the websiteTitle variable. So it‚Äôs made as a private member and will create a public method to let the meant specs file to be able to interact with it. And in this point, all what we need from the websiteTitle is to get its contained text. So here is a function to get it. This function won‚Äôt be marked as private or public because the default access modifier in TypeScript is public.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">getWebsiteTitle</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">websiteTitle</span> <span class="p">}</span>
</code></pre></div></div>

<p>That‚Äôs all for the simple LandingPage page object model. Let‚Äôs move to creating the runner to check this test case.</p>

<h3 id="specs">Specs</h3>

<p>In the specs directory, we will create a subdirectory for each test suite. In this example there is only one test suite -which actually contains only one test case-. So there will be only one subdirectory -for now- called for ‚Äúlanding-page‚Äù for example. This subirectory will contain only two files, one for the configuration and another for the actual specs. Let‚Äôs discuss each one on its own.</p>

<h4 id="the-config-file">The config file</h4>

<p>This config file will hold some data like the browser to run the tests with, the test to be run, and the selenium web address. Protractor supports a huge set of known browser. We will use Google Chrome in our case, but feel free to use any other browser. The specs to be run here is only ‚Äòtest.js‚Äô. Note that it‚Äôs ‚Äòtest.js‚Äô not ‚Äòtest.ts‚Äô. Again, you can‚Äôt run a TypeScript file directly. Instead you generate a converted JavaScript version and run it. The selenium address is also been set here and all the time it should be set to: <a href="http://localhost:4444/wd/hub">http://localhost:4444/wd/hub</a>. The final component of the configuration file is the parameters. The idea behind this parameter section is to keep a single point of contact to them, as well as keep them shared between all the files which can access that configuration file. For example, in our case there will be a base URL parameter which holds the URL of the website where the test cases will run against. If we kept it only in a specific file, so it will be only accessible to its contents. So we can say that the params section is where we store the global variables of project. The final view of the config file should be:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Config</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">protractor</span><span class="dl">"</span>

<span class="k">export</span> <span class="kd">let</span> <span class="nx">config</span><span class="p">:</span> <span class="nx">Config</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">capabilities</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">browserName</span><span class="p">:</span> <span class="dl">"</span><span class="s2">chrome</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">unexpectedAlertBehaviour</span><span class="p">:</span> <span class="dl">'</span><span class="s1">accept</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">chromeOptions</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">args</span><span class="p">:</span> <span class="p">[</span><span class="dl">"</span><span class="s2">--start-maximized</span><span class="dl">"</span><span class="p">]</span>
        <span class="p">}</span>
    <span class="p">},</span>

    <span class="na">specs</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">LandingTest.js</span><span class="dl">'</span><span class="p">],</span>

    <span class="na">seleniumAddress</span><span class="p">:</span> <span class="dl">'</span><span class="s1">http://localhost:4444/wd/hub</span><span class="dl">'</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="the-spec-file">The spec file</h4>

<p>Let‚Äôs talk about this file‚Äôs structure first. As mentioned before, this file will contain all the logic in the test cases. And one of the highest skills of a software tester is being well-organized. That organization is being used all the time by the suppliers of manual software testing providers. And it‚Äôs one of the top reasons why I prefer using Protractor over too many other options when it comes to test automation. It‚Äôs super organized. The main strucure of it is simple. In each file you can list many test suites. In each test suite you can list many test cases. the <code class="highlighter-rouge">describe</code> block represents a test suite and the <code class="highlighter-rouge">it</code> block represents a test case. So a simple file structure could be as following:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">title of a test suite: </span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">title of a test case.</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="p">})</span>

    <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">title of another test case.</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="p">})</span>
<span class="p">})</span>

<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">title of another test suite</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">title of a test case.</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="p">})</span>

    <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">title of another test case.</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>You can add as many test suites as you want in the same file. Also each test suite can hold any number of test cases. But keep in mind too many test cases by a test suite, or to many test suites by a file isn‚Äôt a good practice. It makes the code harder to be read. And also if there is a specific test cases failed in a test run, it becomes harder to trace its failure if there are too many others in the same test suite.</p>

<p>In this section I‚Äôll show the complete version of the file and then dig deeper to its details:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">LandingPage</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../../POMs/LandingPage</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">browser</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">protractor</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">landingPage</span><span class="p">:</span> <span class="nx">LandingPage</span>

<span class="nx">describe</span><span class="p">(</span><span class="dl">'</span><span class="s1">landing page test case: </span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">it</span><span class="p">(</span><span class="dl">'</span><span class="s1">expecting the title of the blog to be "Moataz Mahmoud"</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">landingPage</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">LandingPage</span><span class="p">()</span>
        <span class="nx">browser</span><span class="p">.</span><span class="nx">waitForAngularEnabled</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
        <span class="nx">browser</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">browser</span><span class="p">.</span><span class="nx">params</span><span class="p">.</span><span class="nx">baseURL</span><span class="p">)</span>
        <span class="nx">expect</span><span class="p">(</span><span class="nx">landingPage</span><span class="p">.</span><span class="nx">getWebsiteTitle</span><span class="p">().</span><span class="nx">getText</span><span class="p">()).</span><span class="nx">toContain</span><span class="p">(</span><span class="dl">'</span><span class="s1">Moataz Mahmoud</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>As you can see, the code is self-explanatory. It‚Äôs one test suite with one test case. The test case is ‚Äòexpecting the title of the blog to be ‚ÄúMoataz Mahmoud‚Äù‚Äô. At first, it creates a local object of a LandingPage class. And the scope of this object and where is the best place to define it will be explained in detail in one of the coming posts. The next step is to tell the runner to stop waiting for Angular modules to be loaded since it‚Äôs not an Angular website. If you are testing an Angular application, then you will pass this line. Of course you don‚Äôt want your test to start playing with the content of the page without waiting it to be fully loaded in this case. And make sure that this line is written somewhere before calling the browser.get() function.Then it opens the browser, hits the base URL, and finally expects the page title to be ‚ÄòMoataz Mahmoud‚Äô. That‚Äôs all for this test.</p>

<h2 id="running-the-test">Running the test</h2>

<p>The final step is to run the test. And there are two main steps to be done to run any Protractor test. First you have to run <code class="highlighter-rouge">webdriver-manager start</code>. This command will start up a Selenium Server and will output a bunch of info logs. Your Protractor test will send requests to this server to control a local browser. You can see information about the status of the server at <a href="http://localhost:4444/wd/hub.">http://localhost:4444/wd/hub.</a> The next step is to type <code class="highlighter-rouge">npm run test</code> where test is the name of the script you had previously defined in the package.json file. And once this command starts running it runs three other nested commands. The first command is <code class="highlighter-rouge">npm run tsc</code> where tsc is the mapping for the transpiler which you again should have been defined in the package.json file. This command run the mapping which will run the transpiler to generated the JavaScript version of the test. And the final command is the Protractor command which run the config file of the desired test. Once that last command runs, an instance of the browser you defined in the config.ts file should be opened with the defined options -Google chrome in our case-. AND EVENTUALLY, SET BEACK AND ENJOY YOUR TEST RUNNING üéâüéâüéä.</p>

<p>The final note here is that you can show the details of your running process in the terminal. If the test got failed, you can find a detailed log in the terminal.</p>

<h2 id="wrap-up">Wrap up</h2>

<p>Quickly speaking‚Ä¶
To build a test project you need to:</p>

<ul>
  <li>Get all the dependencies installed.</li>
  <li>Configure the linter.</li>
  <li>Build the page object model.</li>
  <li>Write the configuration of the test.</li>
  <li>Write the specs.</li>
  <li>Fire the tests up from the terminal.</li>
</ul>

<p>That‚Äôs all for the first part of the tutorial. Hope that it was interesting journey. More details and advanced topics regarding to using Protractor for e2e will be covered in the next few posts. so keep tuned! And I want to greet everyone who is still running until this very last line!</p>
:ET